#########################################################################
#
# Makefile used for building application.
#
# The default target (all) builds application in three formats :
#   *.rec : Image in S-record format.
#   *.bin : Image in binary format.
#   *.elf : Image in ELF format.
#   *.map : Linker generated map file.
#   *.dis : Disassembly of image.
#   *.sym : Symbols.
#
# Other targets are :
#   clean :    Deletes all files generated by makefile.
#
#########################################################################
CONFIG_FILE ?= ../../.config
SHELL = /bin/bash

-include $(CONFIG_FILE)    

include ../../config_by_chip.mk 

# **********************************************
# Build Options
# **********************************************

# Version: Debug or Retail
VERSION = Retail

# Endian: EL or EB
ENDIAN  = EL


# **********************************************
# Tool Chain
# **********************************************

# Cross Compile: mips-linux-gnu- or mipsisa32-elf- or mips2_fp_le-
CROSS_COMPILE   = mips-sde-elf-

CC              = $(CROSS_COMPILE)gcc
CPP             = $(CROSS_COMPILE)cpp
LD              = $(CROSS_COMPILE)ld
OBJCOPY         = $(CROSS_COMPILE)objcopy
OBJDUMP         = $(CROSS_COMPILE)objdump
SIZE            = $(CROSS_COMPILE)size
AR              = $(CROSS_COMPILE)ar
NM              = $(CROSS_COMPILE)nm


# **********************************************
# Directories
# **********************************************
ROOT    = .
BINDIR  = bin
BINPATH = $(BINDIR)
OUTDIR  = out
OUTPATH = $(OUTDIR)
OBJDIR  = obj
OBJPATH = $(OBJDIR)
INCDIR  = inc
INCPATH = $(INCDIR)


ifeq ($(CHIP_FAMILY),titania2)
    LOADER = link_titania2.ld
else
    LOADER = link.ld
endif


# Source files

SRC_FILE_AS = \
              src/boot.s                    \
              src/bootram.s
CC_OPTS_AS  = -x assembler-with-cpp -fno-pic -gdwarf-2 -O2 -$(ENDIAN) -mips32 -mno-abicalls -G0
INC_DIR_AS  = \
              -Isrc             \
              -Iout

SRC_FILE_1  = \
              src/nandflash.c   \
              src/uart16550.c   \
              src/setSPI.c
CC_OPTS_1   = -pipe -fno-pic -gdwarf-2 -O0 -$(ENDIAN) -mips32 -mno-abicalls -G0
INC_DIR_1   = \
              -I.

DEFS        = $(shell $(GREP) CONFIG_MSTAR $(AUTOCONF_H) | $(SED) "s/^..*CONFIG_MSTAR/-DCONFIG_MSTAR/" | $(SED) "s/  */=/")
SRC_FILE_2  = \
              src/bootrom.c             \
              src/compat51/drvPmSleep.c \
              src/compat51/drvGlobal.c
CC_OPTS_2   = -pipe -fno-pic -gdwarf-2 -Os -$(ENDIAN) -mips32 -mno-abicalls -G0 $(DEFS)
INC_DIR_2   = \
              -Isrc/compat51                \
              -Iinc                         \
              -Iinc/$(CHIP_FAMILY)/board

SRC_FILE_3  = \
              src/compat51/drvPadConf.c \
              src/compat51/drvMIU.c
CC_OPTS_3   = -pipe -fno-pic -gdwarf-2 -Os -$(ENDIAN) -mips32 -mno-abicalls -G0
INC_DIR_3   = \
              -Isrc/compat51                \
              -Iinc                         \
              -Iinc/$(CHIP_FAMILY)/board

SRC_FILE    = \
              $(SRC_FILE_AS)            \
              $(SRC_FILE_1)             \
              $(SRC_FILE_2)             \
              $(SRC_FILE_3)
CC_OPTS     = $(if $(filter $<,$(SRC_FILE_AS)),$(CC_OPTS_AS),$(if $(filter $<,$(SRC_FILE_1)),$(CC_OPTS_1),$(if $(filter $<,$(SRC_FILE_2)),$(CC_OPTS_2),$(CC_OPTS_3)))) $(INCLUDE)
INCLUDE     = $(if $(filter $<,$(SRC_FILE_AS)),$(INC_DIR_AS),$(if $(filter $<,$(SRC_FILE_1)),$(INC_DIR_1),$(if $(filter $<,$(SRC_FILE_2)),$(INC_DIR_2),$(INC_DIR_3))))

#INC_DIR     = \


# **********************************************
# Image file names
# **********************************************
ALL_BIN         = $(OUTPATH)/all.bin
SBOOT_BIN       = $(OUTPATH)/sboot.bin
SBOOT_ELF       = $(OUTPATH)/sboot.elf
CHAKRA_BIN      = $(BINPATH)/AP.bin
CHAKRA_MAP      = $(BINPATH)/AP.map
PM_BIN          = $(OUTPATH)/PM.bin

CHUNK_HEADER    = $(OUTPATH)/chunk_header.bin
#PAD_BIN         = pad00.bin

AUTOCONF_H      = $(INCPATH)/linux/autoconf.h
CONFIG_H        = $(INCPATH)/config.h
BOOT1_INC       = $(OUTPATH)/boot1.inc
AUTO_GEN_FILE   = $(AUTOCONF_H) $(CONFIG_H) $(BOOT1_INC)

_MMAP_FILE_ = ../../$(MMAP)

# **********************************************
# Tools
# **********************************************
CAT  = /bin/cat
AWK  = /bin/gawk
LS   = /bin/ls
GREP = /bin/grep
SED  = /bin/sed
RM   = /bin/rm
CP   = /bin/cp


# **********************************************
# Files to be compiled
# **********************************************
SRC_S  = $(filter %.s, $(SRC_FILE))
SRC_C  = $(filter %.c, $(SRC_FILE))
SRC_O  = $(filter %.o,  $(SRC_FILE))

OBJ_S  = ${SRC_S:%.s=$(OBJPATH)/%.o}
OBJ_C  = ${SRC_C:%.c=$(OBJPATH)/%.o}

OBJ    = $(OBJ_C) $(OBJ_S)


# ***********************************************************************
# Libraries
# ***********************************************************************

# Standard Libraries


# **********************************************
# Compiler and linker options
# **********************************************

#INCLUDE                 = $(INC_DIR)
#
#CC_TVOPTS              += -$(ENDIAN)
#SBOOT_GLOBAL_CFLAGS     =
#CC_OPTS0                = $(INCLUDE) $(CC_TVOPTS) $(SBOOT_GLOBAL_CFLAGS)
#ifeq ($(VERSION),Debug)
#CC_OPTS                 = $(CC_OPTS0) -O
#else
#CC_OPTS                 = $(CC_OPTS0) -O2
#endif
#
#SBOOT_GLOBAL_LDFLAGS    = -$(ENDIAN)
#LD_OPTS                += $(SBOOT_GLOBAL_LDFLAGS) -LLIB
#LDLIB                  += -lc -lgcc -lm


# **********************************************
# Rules
# **********************************************
.PHONY : all clean # lint
.SUFFIXES:


# Project Build
#all : $(PROJ)
all : $(ALL_BIN)

#$(PROJ) : $(ALL_BIN)

#
# ROM Layout:
#   SBOOT_BIN (boot + bootrom + bootram (nandflash+drvNAND_SLC+uart16550))
#   CHUNK_HEADER
#   CHUNK 1, 2, ... 16
#

ifneq ($(BUILD_TARGET),MAIN_AP_SYSTEM)
    _FLASH_CHUNK_BASE_ADDRESS   = 0
else
    _FLASH_CHUNK_BASE_ADDRESS   = 0x30000
endif

_SIZE_BOOT_BIN              = 65536
_SIZE_PM_BIN              	= 0x10000
ifeq ($(SECURE_BOOT),1)
ifeq ($(BUILD_TARGET),MAIN_AP_SYSTEM)
_SIZE_CHUNK_HEADER          = 1024
LOOP_CNT                    = 128
else
_SIZE_CHUNK_HEADER          = 128
LOOP_CNT                    = 16
endif
else
_SIZE_CHUNK_HEADER          = 128
LOOP_CNT                    = 16
endif
_SIZE_CHAKRA                = $(shell $(LS) -Gl $(CHAKRA_BIN) | $(AWK) '{ print $$4 }')
_RAM_START                  = $(shell $(AWK) '$$2 == "__ram_code_start" { print $$1 }' $(CHAKRA_MAP))
_RAM_END                    = $(shell $(AWK) '$$2 == "__ram_code_end" { print $$1 }' $(CHAKRA_MAP))
_RAM_ENTRY                  = $(shell $(AWK) '$$2 == "reset_vector" { print $$1 }' $(CHAKRA_MAP))
_BEON_MEM_ADR               = $(shell $(AWK) '$$2 == "BEON_MEM_ADR" { print $$3 }' $(_MMAP_FILE_))

ifeq ($(OS_TYPE),nos_aeon)
	SPI_BASE=0x00000000
	RAM_BASE=0x00000000
	#ifeq ($(MEMORY_SIZE),MEMORY_128MB)
	#	BEON_START_OFFSET=0x00400000
	#else
	#	BEON_START_OFFSET=0x00200000
	#endif
	BEON_START_OFFSET = $(shell $(AWK) '$$2 == "BEON_MEM_ADR" { print $$3 }' $(_MMAP_FILE_))
else ifeq ($(OS_TYPE),nos_mips)
	SPI_BASE=0xBFC00000
	RAM_BASE=0x20000000
	BEON_START_OFFSET=0x00000000

else
    error "Error!!"
endif

#	printf "FLASH_CHUNK_BASE_ADDRESS = %s\n" $$FLASH_CHUNK_BASE_ADDRESS;                   \
#	printf "SIZE_BOOT_BIN = %s\n" $$SIZE_BOOT_BIN;          \
#	printf "SIZE_CHUNK_HEADER = %s\n" $$SIZE_CHUNK_HEADER;  \
#	printf "SIZE_CHAKRA = %s\n" $$SIZE_CHAKRA;              \
#	printf "DUMMY_SIZE = %s\n" $$DUMMY_SIZE;                \


$(ALL_BIN) : $(CHUNK_HEADER) $(CHAKRA_BIN)
	@echo "[BIN] $@";                                       \
	FLASH_CHUNK_BASE_ADDRESS=$(_FLASH_CHUNK_BASE_ADDRESS);  \
	SIZE_BOOT_BIN=$(_SIZE_BOOT_BIN);                        \
	SIZE_PM_BIN=$(_SIZE_PM_BIN);                        		\
	SIZE_CHUNK_HEADER=$(_SIZE_CHUNK_HEADER);                \
	SIZE_CHAKRA=$(_SIZE_CHAKRA);                            \
	FLASH_CHUNK_BASE_ADDRESS=$$((FLASH_CHUNK_BASE_ADDRESS+SIZE_BOOT_BIN+SIZE_PM_BIN+SIZE_CHUNK_HEADER+SIZE_ZIPBIN));    \
	$(CAT) $(SBOOT_BIN) > $@;                               \
	$(CAT) $(PM_BIN) >> $@;                               		\
	$(CAT) $(CHUNK_HEADER) >> $@;                           \
	$(CAT) $(CHAKRA_BIN) >> $@;


$(SBOOT_BIN) : $(SBOOT_ELF)
	@echo "[BIN] $@"
	@$(OBJCOPY) -O binary -I $(if $(filter EL,$(ENDIAN)),elf32-little,elf32-big) $< $@

$(SBOOT_ELF) : $(OBJ) $(LOADER)
	@echo "[LD] $@"
	@$(LD) -$(ENDIAN) -o $@ -Map $(subst .elf,.map,$@) -T $(LOADER)
	@$(OBJDUMP) -S $@ > $(subst .elf,.dis,$@)
	@$(SIZE) $@ > $(subst .elf,.siz,$@)

$(AUTOCONF_H) : $(CONFIG_FILE)
	@echo "[GEN] $@"
	@mkdir -p $(dir $@)
	@echo "// This file is auto created. Do not modify!" >  $@
	@echo "#define $(CONFIG_CHIP_FAMILY) 1"              >> $@
	@echo "#define $(CONFIG_BOARD_TYPE) 1"               >> $@
	@echo "#define $(CONFIG_MMAP_TYPE) 1"                >> $@

$(CONFIG_H) : $(CONFIG_FILE)
	@echo "[GEN] $@"
	@mkdir -p $(dir $@)
	@echo "#define $(CONFIG_CHIP_FAMILY2) 1"             >  $@
	@echo                                                >> $@
	@echo "// This file is auto created. Do not modify!" >> $@
	@echo "#include <configs/$(CHIP_FAMILY).h>"          >> $@

$(CHUNK_HEADER) :
	@echo "---------------------------------------"
	@echo "[GEN] $@"
	@echo "OS_TYPE=$(OS_TYPE)"
#	@echo "(CHAKRA_MAP)=$(CHAKRA_MAP)"
	@printf "_SIZE_CHAKRA = 0x%X" $(_SIZE_CHAKRA);
	@printf "(%d)\n" $(_SIZE_CHAKRA);
#	@printf "_MIU_TYPE = 0x%X\n" $(_MIU_TYPE);
#	@printf "_DRAM_TYPE = 0x%X\n" $(_DRAM_TYPE);
	@printf "_BEON_MEM_ADR = 0x%X\n" $(_BEON_MEM_ADR);
#	@printf "_BEON_MEM_ADR = %d\n" $(_BEON_MEM_ADR);
	@printf "RAM_BASE = 0x%X\n" $(RAM_BASE);
	@printf "_RAM_START = 0x%X\n" $(_RAM_START);
	@printf "BEON_START_OFFSET = 0x%X\n" $(BEON_START_OFFSET);
	@mkdir -p $(dir $@)
#	@$(AWK) '{if ($$2=="BEON_MEM_ADR") print "BEON_MEM_ADR=" $$3;}' $(_MMAP_FILE_)
#	@$(AWK) '$$2 == "__ram_code_start" { print "ADDR_AP_RAM_START_ORG = "$$1 }' $(CHAKRA_MAP)   >> $@
#	@$(AWK) '$$2 == "__ram_code_end" { print "ADDR_AP_RAM_END_ORG = "$$1 }' $(CHAKRA_MAP)   >> $@
#	@$(AWK) '$$2 == "reset_vector" { print "ADDR_AP_RAM_BOOT = "$$1 }' $(CHAKRA_MAP)   >> $@
	@printf "SIZE_CHAKRA = 0x"                                                  >> $@
	@printf %08X $(_SIZE_CHAKRA)                                                >> $@
	@printf '\n'
	@echo "---------------------------------------"                                      >> $@
	@FLASH_CHUNK_BASE_ADDRESS=$(_FLASH_CHUNK_BASE_ADDRESS); \
	SIZE_BOOT_BIN=$(_SIZE_BOOT_BIN); \
	SIZE_PM_BIN=$(_SIZE_PM_BIN);                        		\
	SIZE_CHUNK_HEADER=$(_SIZE_CHUNK_HEADER); \
	FLASH_CHUNK_BASE_ADDRESS=$$((FLASH_CHUNK_BASE_ADDRESS+SIZE_BOOT_BIN+SIZE_PM_BIN+SIZE_CHUNK_HEADER+SIZE_ZIPBIN));    \
	CUR_CHUNK=$$FLASH_CHUNK_BASE_ADDRESS; \
	ROM_START=$$((FLASH_CHUNK_BASE_ADDRESS+$(SPI_BASE))); \
	RAM_START=$$(($(_RAM_START)+$(RAM_BASE)+$(BEON_START_OFFSET))); \
	RAM_END=$$(($(_RAM_START)+$(_SIZE_CHAKRA)+$(RAM_BASE)+$(BEON_START_OFFSET))); \
	ROM_END=$$((FLASH_CHUNK_BASE_ADDRESS+$(_SIZE_CHAKRA)+$(SPI_BASE))); \
#	printf "_SIZE_CHAKRA = 0x"; \
#	printf %08X $(_SIZE_CHAKRA); \
#	printf '\n'; \
#	printf "ROM_START = 0x"; \
#	printf %08X $$ROM_START; \
#	printf '\n'; \
#	printf "RAM_START = 0x"; \
#	printf %08X $$RAM_START; \
#	printf '\n'; \
#	printf "RAM_END = 0x"; \
#	printf %08X $$RAM_END; \
#	printf '\n'; \
#	printf "ROM_END = 0x"; \
#	printf %08X $$ROM_END; \
#	printf '\n'; \
	printf "ROM_START = 0x%08X\n" $$ROM_START; \
	printf "RAM_START = 0x%08X\n" $$RAM_START; \
	printf "RAM_END   = 0x%08X\n" $$RAM_END; \
	printf "ROM_END   = 0x%08X\n" $$ROM_END; \
	# ================================================================== \
	# Begin generate chunk_header.bin ...  \
	for (( i=1; i<=$(LOOP_CNT); i=i+1 )) \
	do \
	    if [ "$${CHUNK[$$i]}" != "" ] ; then \
	        test -e $${CHUNK[$$i]} && SIZE_CHUNK=`$(LS) -Gl $${CHUNK[$$i]} | $(AWK) '{ print $$4 }'`; \
	    else \
	        SIZE_CHUNK=0; \
	    fi; \
	    if [ "$$SIZE_CHUNK" != "0" ] ; then \
	        printf "\n# ==== Chunk $${CHUNK[$$i]} size ==== \n" >> $@; \
	        printf "SIZE_CHUNK$$i = 0x" >> $@; \
	        printf %08X "$$SIZE_CHUNK"  >> $@; \
	        printf '\n# ================================== \n' >> $@; \
	    fi; \
	    if [ "$$SIZE_CHUNK" != "0" ] ; then \
	        printf "\n# ==== Chunk $${CHUNK[$$i]} at flash address ====\n" >> $@; \
	        printf "ADDR_CHUNK$$i = 0x" >> $@; \
	        printf %08X "$$CUR_CHUNK"  >> $@; \
	        printf '\n# ============================================== \n' >> $@; \
	        BYTE_0=$$((CUR_CHUNK&255)); \
	        BYTE_1=$$(((CUR_CHUNK>>8)&255)); \
	        BYTE_2=$$(((CUR_CHUNK>>16)&255)); \
	        BYTE_3=$$(((CUR_CHUNK>>24)&255)); \
	        SBYTE_0=$$((SIZE_CHUNK&255)); \
	        SBYTE_1=$$(((SIZE_CHUNK>>8)&255)); \
	        SBYTE_2=$$(((SIZE_CHUNK>>16)&255)); \
	        SBYTE_3=$$(((SIZE_CHUNK>>24)&255)); \
	        CUR_CHUNK=$$((CUR_CHUNK+SIZE_CHUNK)); \
	    else \
	        BYTE_0=$$((0)); \
	        BYTE_1=$$((0)); \
	        BYTE_2=$$((0)); \
	        BYTE_3=$$((0)); \
	        SBYTE_0=$$((0)); \
	        SBYTE_1=$$((0)); \
	        SBYTE_2=$$((0)); \
	        SBYTE_3=$$((0)); \
	    fi; \
	    if [ $$((i==1)) == 1 ] ; then \
	        BYTE_0=$$((ROM_START&255)); \
	        BYTE_1=$$(((ROM_START>>8)&255)); \
	        BYTE_2=$$(((ROM_START>>16)&255)); \
	        BYTE_3=$$(((ROM_START>>24)&255)); \
	        SBYTE_0=$$((RAM_START&255)); \
	        SBYTE_1=$$(((RAM_START>>8)&255)); \
	        SBYTE_2=$$(((RAM_START>>16)&255)); \
	        SBYTE_3=$$(((RAM_START>>24)&255)); \
	        $(AWK) 'BEGIN{printf("%c%c%c%c",'"$$BYTE_0"', '"$$BYTE_1"', '"$$BYTE_2"', '"$$BYTE_3"')}'     >  $(CHUNK_HEADER); \
	        $(AWK) 'BEGIN{printf("%c%c%c%c",'"$$SBYTE_0"', '"$$SBYTE_1"', '"$$SBYTE_2"', '"$$SBYTE_3"')}' >> $(CHUNK_HEADER); \
	    else \
	        if [ $$((i==2)) == 1 ] ; then \
	            BYTE_0=$$((RAM_END&255)); \
	            BYTE_1=$$(((RAM_END>>8)&255)); \
	            BYTE_2=$$(((RAM_END>>16)&255)); \
	            BYTE_3=$$(((RAM_END>>24)&255)); \
	            SBYTE_0=$$((ROM_END&255)); \
	            SBYTE_1=$$(((ROM_END>>8)&255)); \
	            SBYTE_2=$$(((ROM_END>>16)&255)); \
	            SBYTE_3=$$(((ROM_END>>24)&255)); \
	            $(AWK) 'BEGIN{printf("%c%c%c%c",'"$$BYTE_0"', '"$$BYTE_1"', '"$$BYTE_2"', '"$$BYTE_3"')}'     >>  $(CHUNK_HEADER); \
	            $(AWK) 'BEGIN{printf("%c%c%c%c",'"$$SBYTE_0"', '"$$SBYTE_1"', '"$$SBYTE_2"', '"$$SBYTE_3"')}' >> $(CHUNK_HEADER); \
	        else \
	            if [ $$((i==3)) == 1 ] ; then \
	                __RAM_ENTRY=$(_RAM_ENTRY); \
	                BYTE_0=$$((__RAM_ENTRY&255)); \
	                BYTE_1=$$(((__RAM_ENTRY>>8)&255)); \
	                BYTE_2=$$(((__RAM_ENTRY>>16)&255)); \
	                BYTE_3=$$(((__RAM_ENTRY>>24)&255)); \
	                SBYTE_0=$$((0)); \
	                SBYTE_1=$$((0)); \
	                SBYTE_2=$$((0)); \
	                SBYTE_3=$$((0)); \
	                $(AWK) 'BEGIN{printf("%c%c%c%c",'"$$BYTE_0"', '"$$BYTE_1"', '"$$BYTE_2"', '"$$BYTE_3"')}'     >>  $(CHUNK_HEADER); \
	                $(AWK) 'BEGIN{printf("%c%c%c%c",'"$$SBYTE_0"', '"$$SBYTE_1"', '"$$SBYTE_2"', '"$$SBYTE_3"')}' >> $(CHUNK_HEADER); \
	            else \
	                $(AWK) 'BEGIN{printf("%c%c%c%c",'"$$BYTE_0"', '"$$BYTE_1"', '"$$BYTE_2"', '"$$BYTE_3"')}'     >>  $(CHUNK_HEADER); \
	                $(AWK) 'BEGIN{printf("%c%c%c%c",'"$$SBYTE_0"', '"$$SBYTE_1"', '"$$SBYTE_2"', '"$$SBYTE_3"')}' >> $(CHUNK_HEADER); \
	            fi; \
	        fi; \
	    fi; \
	done

$(OBJPATH)/%.o : %.s $(AUTO_GEN_FILE)
	$(call make-depend-compile,$<,$@,$(subst .o,.d,$@))

$(OBJPATH)/%.o : %.c $(AUTO_GEN_FILE)
	$(call make-depend-compile,$<,$@,$(subst .o,.d,$@))


# Project Clean
clean :
	$(RM) -rf $(OBJPATH) $(OUTPATH) $(AUTO_GEN_FILE) $(ROOT)/$(notdir $(BOOT1_INC))


# Project Dependence

# $(call make-depend-compile,source-file,object-file,depend-file)
define make-depend-compile
	@echo "[CC]  $1"
	@mkdir -p $(dir $2)
	@$(CC) -MM -MF $3 -MP -MT $2 $(CC_OPTS) $1
	@$(CC) $(CC_OPTS) -o $2 -c $1
	@$(CP) $2 $(OBJPATH)
endef

-include $(OBJ_S:.o=.d) $(OBJ_C:.o=.d)
